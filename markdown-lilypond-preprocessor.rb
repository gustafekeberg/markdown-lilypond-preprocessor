#!/usr/bin/env ruby -E utf-8
#<Encoding:UTF-8>

require 'fileutils'
require 'yaml'
require 'digest/sha1'

# This script should be run from Marked 2 to work

# Change dir to MARKED_ORIGIN path env var set by Marked and assign variables for all env vars.
Dir.chdir(ENV['MARKED_ORIGIN'])

def log( data )
	timestamp = Time.now.getutc
	file = $mlpp_marked_path
	output = "  \n`#{timestamp}` (`#{file}`): #{data}"
	log_path = File.join($mlpp_script_dir, "log.txt")
	File.open(log_path, 'a') { |f| f.write(output) }
end

def read_config( file )
	# Read config file, create it with default values if it doesn't exist
	
	def write_default_config( file )
		
		default_config = YAML.load_file( File.join( $mlpp_lib_dir, "default_config" ))
		dirname = File.dirname( file )
		
		unless File.directory?( dirname )
			FileUtils.mkdir_p( dirname )
		end
		IO.write( file, YAML.dump(default_config) )
		return default_config
	end
	
	if File.file?( file )
		config = YAML.load_file( file )
		if !config
			config = write_default_config( file )
		end
	else
		config = write_default_config( file )
	end
	return config
end

def find_and_process_snippets( markdown )
	
	# Regex to find lilypond snippets. First part determines if it is a code-block or else checks if it's a LilyPond-snippet.
	re_get_snippet = /((^`{3,})\w*\n[\s\S]*?\n(\2))|^(?:<!--\s*(lilypond-(?:snippet|simple|full))\s*-->$\n(?:(```)\w*$)*)([\s\S]*?)(\5*\n<!--\s*\4\s*-->)/mi

	# Find all simple snippets in markdown and process them.
	processed_markdown = markdown.gsub(re_get_snippet).with_index do | m, index |
		if $2 # If group 2 is present, then it should display as code - proceed without processing
			$1
		else # Else check what type of snippet (simple|full|...)
			case $4
			when "lilypond-snippet"
				output_src = process_lilypond_snippet($6, index)
				"<figure class=\"music-container\"><img src=\"#{output_src["file"]}\" /></figure>"
			else
				"*The `#{$4}`-tag is not yet implemented!*"
			end
		end
	end
	return processed_markdown
end

def process_lilypond_snippet(snippet, index)
	
	# Regex to get snippet data, group 1 = config, group 2 = music.
	extracted_data = /(?:^---\s*([\s\S]*)---\s*$([\s\S]*))/.match( snippet )
	
	# Process config and music.
	lilypond_config = ""
	if extracted_data then
		lilypond_config = YAML.load( extracted_data[1] ) unless extracted_data[1] == ""
		lilypond_content = extracted_data[2]
	else
		# If extracted_data is empty just pass full snippet as lilypond conten
		lilypond_content = snippet
	end
	# Make lilypond file from snippet data
	file_src = make_lilypond_output( {
		"lilypond_config"       => lilypond_config,
		"lilypond_content" => lilypond_content,
		}, index )
	return file_src
end

def make_lilypond_output( lilypond_obj, index )
	# Construct the lilypond file and run LilyPond on it to get image
	
	def make_filenames( obj )
		# Get full path to data-dir, make dir if it doesn't exist yet, goto dir
		lilypond_dir = File.expand_path( $mlpp_lilypond_data_dir_full_path )
		FileUtils.mkdir_p( lilypond_dir )
		Dir.chdir(lilypond_dir)

		simple_snippet_filename = "#{obj["lilypond_filename"]}-#{obj["index"]}.ly"
		simple_snippet_filename_lastrun = "_#{simple_snippet_filename}"

		# Filenames of lilypond snippet files and last run files
		lilypond_filename = File.join(lilypond_dir, "#{obj["lilypond_filename"]}-#{obj["index"]}.ly")
		lilypond_last_run_filename = File.join(lilypond_dir, simple_snippet_filename_lastrun)
		lilypond_basename = File.basename(lilypond_filename, ".ly")
		return {
			"name" => lilypond_filename,
			"lastrun" => lilypond_last_run_filename,
			"basename" => lilypond_basename,
		}
	end
	
	filename = make_filenames({
		"lilypond_filename" => "lilypond-snippet",
		"last_run_prefix" => "_",
		"index" => index,
		})

	template = get_lilypond_template( lilypond_obj["lilypond_config"]["template"], index )

	# Produce lilypond code from snippet data and template file
	constructed_lilypond_code = replace_placeholders_in_template({
		"variables" => lilypond_obj["lilypond_config"]["variables"],
		"content"   => lilypond_obj["lilypond_content"],
		"template"  => template["content"],
		"config"    => lilypond_obj["lilypond_config"]
		})

	# Write lilypond code to disk
	IO.write( filename["name"], constructed_lilypond_code)

	
	# If there exist a previous version of the lilypond code read it
	if File.file?(filename["lastrun"])
	
		# Check if lilypond-snippet files has changed since last run, then run LilyPond
		last_run_file_content = File.read( filename["lastrun"] )
	else
		last_run_file_content = ""
	end

	if constructed_lilypond_code != last_run_file_content
		# Copy last run lilypond file before generating new output.
		`cp "#{filename["name"]}" "#{filename["lastrun"]}"`

		# Run LilyPond command
		`#{$mlpp_lilypond_bin} #{$mlpp_lilypond_argumets} "#{filename["name"]}"`
		# Clean up unused files generated by LilyPond
		`rm #{filename["basename"]}*.eps #{filename["basename"]}*.count #{filename["basename"]}*.tex #{filename["basename"]}*.texi`
	end

	sha_query_string = Digest::SHA1.hexdigest( constructed_lilypond_code )
	# Add a timestamp to prevent caching of image
	generated_file = File.join($mlpp_lilypond_data_dir_relative_path, "#{filename["basename"]}.png?sha=#{sha_query_string}")
	message        = template["message"]
	return {"file" => generated_file, "message" => message}
end

def run_lilypond( obj )
	filename = obj["name"] # Move filename function to run_lilypond
	type = obj["type"]
	dpi = obj["dpi"]
	generated_file = "#{filename}.#{type}"
	return generated_file
end

def replace_placeholders_in_template( obj )
	template = obj["template"]
	unless obj["config"]["content_placeholder"]
		lilypond_content_placeholder = '#{lilypond_content}'
	else
		lilypond_content_placeholder = "\#\{#{obj["config"]["content_placeholder"]}\}"
	end

	template = template.gsub(lilypond_content_placeholder, obj["content"])
	if obj["variables"]
		obj["variables"].each do | key, var |
			template = template.gsub("\#\{#{key}\}", var)
		end
	end
	return template
end


def get_lilypond_template( template_file, index = '?')
	log_template = false
	# Set default template if template_file is empty or not set
	if !template_file
		template_file = $mlpp_default_template
	end
	
	# Search for templates:
	# 
	# 1. If env var MARKED_ORIGIN is set, start searching for templates here
	# 2. Look in $HOME/."processor_name"/templates
	# 3. (Use the built in template, located?)
	# 
	# return template

	template_path = File.join(
		File.dirname(template_file),
		File.basename(template_file, ".*") + ".ly"
		)

	# Different locations to look for template
	marked_origin_template = File.join( $mlpp_marked_origin, template_path )
	template_dir_template = File.join( $mlpp_template_dir, template_path )

	template_message = ''

	# Search for file as entered
	if File.file?( File.expand_path( template_path ))
		template_content = IO.read( template_path )
		if log_template
			log( "Template found (#{index}):\n #{template_file}" )
		end
	# Search for file in marked_origin dir
	
elsif File.file?( marked_origin_template )
	template_content = IO.read( marked_origin_template )
	if log_template
		log( "Template found (#{index}):\n #{marked_origin_template}" )
	end

	# Search in template dir in user-root
	
elsif File.file?( template_dir_template )
	template_content = IO.read( template_dir_template )
	if log_template
		log( "Template found (#{index}):\n #{template_dir_template}" )
	end
else
		# Get builtin template if template not found
		template_content = IO.read( $mlpp_builtin_template )
		template_message = "___Template `#{template_path}` in the snippet no `#{index}` was not found.___"

	end
	return {"content" => template_content, "message" => template_message}
end

# Global variables
$mlpp_marked_origin                   = ENV['MARKED_ORIGIN'].dup.force_encoding("UTF-8")
$mlpp_marked_path                     = ENV['MARKED_PATH'].dup.force_encoding("UTF-8")
$mlpp_marked_ext                      = ENV['MARKED_EXT'].dup.force_encoding("UTF-8")
$mlpp_marked_filename                 = File.basename($mlpp_marked_path, ".#{$mlpp_marked_ext}")
$mlpp_lilypond_data_dir_relative_path = "./#{$mlpp_marked_filename}-lilypond-data"
$mlpp_lilypond_data_dir_full_path     = File.join($mlpp_marked_origin, $mlpp_lilypond_data_dir_relative_path)
$mlpp_script_dir                      = File.dirname(__FILE__)
$mlpp_lib_dir                         = File.join( $mlpp_script_dir, "lib" )
$mlpp_home_dir                        = File.join(ENV['HOME'], ".markdown-lilypond-preprocessor")
$mlpp_config_file                     = File.join($mlpp_home_dir, "config")
$mlpp_template_dir                    = File.join($mlpp_home_dir, "templates")
$mlpp_builtin_template                = File.join($mlpp_script_dir, "lib/default-template.ly")
$mlpp_default_template                = $mlpp_builtin_template
$mlpp_config                          = read_config( $mlpp_config_file )
$mlpp_lilypond_bin                    = $mlpp_config["lilypond_bin"]
$mlpp_lilypond_argumets               = '-dbackend=eps -dresolution=600 --png'

if $mlpp_config["default_template"]
	$mlpp_default_template = $mlpp_config["default_template"]
end

input = $stdin.read
processed_markdown = find_and_process_snippets( input )
$stdout.print processed_markdown